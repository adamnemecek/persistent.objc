//
//  PrefixHeader.pch
//  Persistent
//
//  Created by Anton Astashov on 04/10/14.
//  Copyright (c) 2014 Anton Astashov. All rights reserved.
//

#import "AAVNode.h"
#import "AABitmapIndexedNode.h"
#import "AAHashCollisionNode.h"
#import "AABool.h"

#ifndef Persistent_PrefixHeader_pch
#define Persistent_PrefixHeader_pch

static const NSUInteger SHIFT = 5;
static const NSUInteger SIZE = 1 << SHIFT;
static const NSUInteger MASK = SIZE - 1;

static AAVNode *maybeCopyVNode(AAVNode *node, AAOwner *owner) {
    if (owner != nil && node != nil && owner == node.owner) {
        return node;
    } else {
        return [[AAVNode alloc]
            initWithArray: (node != nil ? [NSMutableArray arrayWithArray:node.array] : [NSMutableArray array])
            andOwner: owner
        ];
    }
}

static NSUInteger mask(NSUInteger hash, NSUInteger shift) {
    return (hash >> shift) & MASK;
}

static NSUInteger bitpos(NSUInteger hash, NSUInteger shift) {
    return 1 << mask(hash, shift);
}


static id<AAINode> createNode(NSUInteger shift, id key1, id val1, id key2, id val2, AAOwner *owner) {
    NSUInteger key1hash = [key1 hash];
    NSUInteger key2hash = [key2 hash];
    if (key1hash == key2hash) {
        NSMutableArray *newArray = [[NSMutableArray alloc] initWithObjects:key1, val1, key2, val2, nil];
        return [[AAHashCollisionNode alloc] initWithHash:key1hash count:2 array:newArray owner:owner];
    } else {
        AABool *didAddLeaf = [[AABool alloc] init];
        return [[[AABitmapIndexedNode empty]
                    set:key1 withValue:val1 shift:shift didAddLeaf:didAddLeaf owner:owner]
                    set:key2 withValue:val2 shift:shift didAddLeaf:didAddLeaf owner:owner];

    }
}

static NSString *ib(int intValue) {
    int byteBlock = SHIFT,    // 8 bits per byte
        totalBits = SIZE, // Total bits
        binaryDigit = 1,  // Current masked bit
        byteBlockShift = SIZE % SHIFT;

    // Binary string
    NSMutableString *binaryStr = [[NSMutableString alloc] init];

    do
    {
        // Check next bit, shift contents left, append 0 or 1
        [binaryStr insertString:((intValue & binaryDigit) ? @"1" : @"0" ) atIndex:0];

        // More bits? On byte boundary ?
        if (--totalBits && !((totalBits - byteBlockShift) % byteBlock))
            [binaryStr insertString:@"|" atIndex:0];

        // Move to next bit
        binaryDigit <<= 1;

    } while (totalBits);

    // Return binary string
    return binaryStr;
}


// Jenkins hash functions

static NSUInteger hashCombine(NSUInteger hash, NSUInteger value) {
    hash = 0x1fffffff & (hash + value);
    hash = 0x1fffffff & (hash + ((0x0007ffff & hash) << 10));
    return hash ^ (hash >> 6);
}

static NSUInteger finish(NSUInteger hash) {
    hash = 0x1fffffff & (hash + ((0x03ffffff & hash) << 3));
    hash = hash ^ (hash >> 11);
    return 0x1fffffff & (hash + ((0x00003fff & hash) << 15));
}

//

static NSUInteger hashObjects(NSObject<NSFastEnumeration> *objects) {
    NSUInteger hash = 0;
    for (id object in objects) {
        hash = hashCombine(hash, [object hash]);
    }
    return finish(hash);
}

#endif
